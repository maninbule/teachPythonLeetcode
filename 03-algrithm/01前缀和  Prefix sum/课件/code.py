'''
什么是前缀和？
前缀和的定义很简单，就是用一个数字来表示前面一串数字的和
比如下面的数组是：
前缀和的定义
'''
A = [1,3,2,6,7,8]
pre = [0,0,0,0,0,0]
pre[0] = A[0]
pre[1] = A[0] + A[1]
pre[2] = A[0] + A[1] + A[2]
pre[3] = A[0] + A[1] + A[2] + A[3]
'''

也就是pre[i] = A[j](其中j <=i)，第i个前缀和就是所有下标小于等于自己下标的原数组的元素和
通过上面，我们可以得出一个递推式
pre[0] = A[0]
之后的所有pre[i] = pre[i-1] + A[i]
 通过这个递推式，我们就可以用O(n)的复杂度求出前缀和数组
'''
A = [1,3,2,6,7,8]
pre = [0] * len(A)
pre[0] = A[0]
for i in range(1,len(A)):
    pre[i] = pre[i-1] + A[i]
'''
知道了前缀和，如果求得区间和
假如我们要求区间下标为[L,R]的元素和，我们知道pre[R]是前R下标的元素和，可以知道相比我们要求的区间和，pre[R]多了前L-1下标，所以我们用pre[R] - pre[L-1]就得到了区间[L,R]的元素和
前缀和一般用来做什么呢？
用于频繁的区间求和
假如说我们知道了一个数组A，数组的长度是n，然后有q次询问，每次询问数组下标在区间[L,R]的元素和。
如果我们用暴力的方法来做，每次询问的时间复杂度就是O(n), 然后一共有q次询问，时间复杂度就是O(nq)

如果我们采用前缀和的方法来做，时间复杂度是多少呢？
首先处理出前缀和数组，时间复杂度O(n)，之后每次询问就直接用一个式子pre[R] - pre[L-1]就求出来了。询问的时间复杂度就变成了O(1),总的时间复杂度就是O(n + q)了。

可以看出O(n + q) 远远小于 O (nq)
处理技巧
对于pre[R] - pre[L-1]只适用于L 大于等于1的情况，而L = 0的时候，我们需要把pre[R] - pre[L-1]写成pre[R]. 意思就是求区间下标在[0,R]的时候，只用写pre[R]就可以了。 有个比较好的技巧可以让我们可以统一用pre[R] - pre[L-1]来求区间和，就是让下标从1开始，然后令pre[0] = 0
也就是原来的数组是
'''
A = [1,3,2,6,7,8]
# 我们变成A = [0,1,3,2,6,7,8]
pre[0] = A[0]
pre[1] = A[0] + A[1]
pre[2] = A[0] + A[1] + A[2]
pre[3] = A[0] + A[1] + A[2] + A[3]
'''
前面补了一个0，是不影响前缀和的
原来是pre[i] = 前i个下标的和
现在变成了 前i个下标的和 + 0
效果是一样的
'''